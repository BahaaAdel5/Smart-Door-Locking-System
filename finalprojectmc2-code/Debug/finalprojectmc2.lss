
finalprojectmc2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000009a0  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000000e  00800060  000009a0  00000a34  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000014  0080006e  0080006e  00000a42  2**0
                  ALLOC
  3 .stab         000015a8  00000000  00000000  00000a44  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00000f63  00000000  00000000  00001fec  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
   4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
   c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  1c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  24:	0c 94 f9 02 	jmp	0x5f2	; 0x5f2 <__vector_9>
  28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
  50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
  54:	11 24       	eor	r1, r1
  56:	1f be       	out	0x3f, r1	; 63
  58:	cf e5       	ldi	r28, 0x5F	; 95
  5a:	d4 e0       	ldi	r29, 0x04	; 4
  5c:	de bf       	out	0x3e, r29	; 62
  5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
  60:	10 e0       	ldi	r17, 0x00	; 0
  62:	a0 e6       	ldi	r26, 0x60	; 96
  64:	b0 e0       	ldi	r27, 0x00	; 0
  66:	e0 ea       	ldi	r30, 0xA0	; 160
  68:	f9 e0       	ldi	r31, 0x09	; 9
  6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
  6c:	05 90       	lpm	r0, Z+
  6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
  70:	ae 36       	cpi	r26, 0x6E	; 110
  72:	b1 07       	cpc	r27, r17
  74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
  76:	10 e0       	ldi	r17, 0x00	; 0
  78:	ae e6       	ldi	r26, 0x6E	; 110
  7a:	b0 e0       	ldi	r27, 0x00	; 0
  7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
  7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
  80:	a2 38       	cpi	r26, 0x82	; 130
  82:	b1 07       	cpc	r27, r17
  84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
  86:	0e 94 85 01 	call	0x30a	; 0x30a <main>
  8a:	0c 94 ce 04 	jmp	0x99c	; 0x99c <_exit>

0000008e <__bad_interrupt>:
  8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <timer_fn>:

/*------------------------------------------------------------------------------
[Function Name]: timer_fn
[Description]: counts 60 seconds after callback from timer0 driver
------------------------------------------------------------------------------*/
void timer_fn(){
  92:	df 93       	push	r29
  94:	cf 93       	push	r28
  96:	cd b7       	in	r28, 0x3d	; 61
  98:	de b7       	in	r29, 0x3e	; 62
	g_tick++; /*increment ticks counter every timer overflow*/
  9a:	80 91 70 00 	lds	r24, 0x0070
  9e:	90 91 71 00 	lds	r25, 0x0071
  a2:	01 96       	adiw	r24, 0x01	; 1
  a4:	90 93 71 00 	sts	0x0071, r25
  a8:	80 93 70 00 	sts	0x0070, r24

	if(g_tick > 31*60){ /*60 seconds buzzer*/
  ac:	80 91 70 00 	lds	r24, 0x0070
  b0:	90 91 71 00 	lds	r25, 0x0071
  b4:	27 e0       	ldi	r18, 0x07	; 7
  b6:	85 34       	cpi	r24, 0x45	; 69
  b8:	92 07       	cpc	r25, r18
  ba:	38 f0       	brcs	.+14     	; 0xca <timer_fn+0x38>
		buzzerFlag = 1; /*set buzzer flag = 1 after 60 seconds*/
  bc:	81 e0       	ldi	r24, 0x01	; 1
  be:	80 93 72 00 	sts	0x0072, r24
		g_tick = 0; //clear the tick counter again to count a new 60 seconds when needed
  c2:	10 92 71 00 	sts	0x0071, r1
  c6:	10 92 70 00 	sts	0x0070, r1
	}

}
  ca:	cf 91       	pop	r28
  cc:	df 91       	pop	r29
  ce:	08 95       	ret

000000d0 <storePassFirst>:

/*------------------------------------------------------------------------------
[Function Name]: storePassFirst
[Description]: store password entered on keypad @ MC1 here on the EEPROM
------------------------------------------------------------------------------*/
void storePassFirst(){
  d0:	df 93       	push	r29
  d2:	cf 93       	push	r28
  d4:	cd b7       	in	r28, 0x3d	; 61
  d6:	de b7       	in	r29, 0x3e	; 62
	key1 = UART_recieveByte(); /*receive byte from MC1 and store it in key1 variable*/
  d8:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
  dc:	80 93 7b 00 	sts	0x007B, r24
	EEPROM_writeByte(0x0311,key1); /*write key1 byte in location 0x0311 in EEPROM */
  e0:	20 91 7b 00 	lds	r18, 0x007B
  e4:	81 e1       	ldi	r24, 0x11	; 17
  e6:	93 e0       	ldi	r25, 0x03	; 3
  e8:	62 2f       	mov	r22, r18
  ea:	0e 94 cf 01 	call	0x39e	; 0x39e <EEPROM_writeByte>

	key2 = UART_recieveByte();
  ee:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
  f2:	80 93 7e 00 	sts	0x007E, r24
	EEPROM_writeByte(0x0312,key2); /*write key2 byte in location 0x0312 in EEPROM */
  f6:	20 91 7e 00 	lds	r18, 0x007E
  fa:	82 e1       	ldi	r24, 0x12	; 18
  fc:	93 e0       	ldi	r25, 0x03	; 3
  fe:	62 2f       	mov	r22, r18
 100:	0e 94 cf 01 	call	0x39e	; 0x39e <EEPROM_writeByte>

	key3 = UART_recieveByte();
 104:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 108:	80 93 7d 00 	sts	0x007D, r24
	EEPROM_writeByte(0x0313,key3); /*write key3 byte in location 0x0313 in EEPROM */
 10c:	20 91 7d 00 	lds	r18, 0x007D
 110:	83 e1       	ldi	r24, 0x13	; 19
 112:	93 e0       	ldi	r25, 0x03	; 3
 114:	62 2f       	mov	r22, r18
 116:	0e 94 cf 01 	call	0x39e	; 0x39e <EEPROM_writeByte>

	key4 = UART_recieveByte();
 11a:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 11e:	80 93 76 00 	sts	0x0076, r24
	EEPROM_writeByte(0x0314,key4); /*write key4 byte in location 0x0314 in EEPROM */
 122:	20 91 76 00 	lds	r18, 0x0076
 126:	84 e1       	ldi	r24, 0x14	; 20
 128:	93 e0       	ldi	r25, 0x03	; 3
 12a:	62 2f       	mov	r22, r18
 12c:	0e 94 cf 01 	call	0x39e	; 0x39e <EEPROM_writeByte>

	key5 = UART_recieveByte();
 130:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 134:	80 93 77 00 	sts	0x0077, r24
	EEPROM_writeByte(0x0315,key5); /*write key5 byte in location 0x0315 in EEPROM */
 138:	20 91 77 00 	lds	r18, 0x0077
 13c:	85 e1       	ldi	r24, 0x15	; 21
 13e:	93 e0       	ldi	r25, 0x03	; 3
 140:	62 2f       	mov	r22, r18
 142:	0e 94 cf 01 	call	0x39e	; 0x39e <EEPROM_writeByte>
}
 146:	cf 91       	pop	r28
 148:	df 91       	pop	r29
 14a:	08 95       	ret

0000014c <storePassCheck>:

/*------------------------------------------------------------------------------
[Function Name]: storePassCheck
[Description]: Check the entered password with the one stored @ EEPROM and send confirmation to MC1
------------------------------------------------------------------------------*/
void storePassCheck(){
 14c:	df 93       	push	r29
 14e:	cf 93       	push	r28
 150:	cd b7       	in	r28, 0x3d	; 61
 152:	de b7       	in	r29, 0x3e	; 62
	key1 = UART_recieveByte(); /*receive byte from MC1 and store it in key1 variable*/
 154:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 158:	80 93 7b 00 	sts	0x007B, r24
	EEPROM_readByte(0x0311, &key11); /*read byte from EEPROM location 0x0311 and store it in key11 variable*/
 15c:	2a e7       	ldi	r18, 0x7A	; 122
 15e:	30 e0       	ldi	r19, 0x00	; 0
 160:	81 e1       	ldi	r24, 0x11	; 17
 162:	93 e0       	ldi	r25, 0x03	; 3
 164:	b9 01       	movw	r22, r18
 166:	0e 94 10 02 	call	0x420	; 0x420 <EEPROM_readByte>

	key2 = UART_recieveByte();
 16a:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 16e:	80 93 7e 00 	sts	0x007E, r24
	EEPROM_readByte(0x0312, &key22); /*read byte from EEPROM location 0x0312 and store it in key22 variable*/
 172:	2f e7       	ldi	r18, 0x7F	; 127
 174:	30 e0       	ldi	r19, 0x00	; 0
 176:	82 e1       	ldi	r24, 0x12	; 18
 178:	93 e0       	ldi	r25, 0x03	; 3
 17a:	b9 01       	movw	r22, r18
 17c:	0e 94 10 02 	call	0x420	; 0x420 <EEPROM_readByte>

	key3 = UART_recieveByte();
 180:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 184:	80 93 7d 00 	sts	0x007D, r24
	EEPROM_readByte(0x0313, &key33); /*read byte from EEPROM location 0x0313 and store it in key33 variable*/
 188:	28 e7       	ldi	r18, 0x78	; 120
 18a:	30 e0       	ldi	r19, 0x00	; 0
 18c:	83 e1       	ldi	r24, 0x13	; 19
 18e:	93 e0       	ldi	r25, 0x03	; 3
 190:	b9 01       	movw	r22, r18
 192:	0e 94 10 02 	call	0x420	; 0x420 <EEPROM_readByte>

	key4 = UART_recieveByte();
 196:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 19a:	80 93 76 00 	sts	0x0076, r24
	EEPROM_readByte(0x0314, &key44); /*read byte from EEPROM location 0x0314 and store it in key44 variable*/
 19e:	2c e7       	ldi	r18, 0x7C	; 124
 1a0:	30 e0       	ldi	r19, 0x00	; 0
 1a2:	84 e1       	ldi	r24, 0x14	; 20
 1a4:	93 e0       	ldi	r25, 0x03	; 3
 1a6:	b9 01       	movw	r22, r18
 1a8:	0e 94 10 02 	call	0x420	; 0x420 <EEPROM_readByte>

	key5 = UART_recieveByte();
 1ac:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 1b0:	80 93 77 00 	sts	0x0077, r24
	EEPROM_readByte(0x0315, &key55); /*read byte from EEPROM location 0x0315 and store it in key55 variable*/
 1b4:	25 e7       	ldi	r18, 0x75	; 117
 1b6:	30 e0       	ldi	r19, 0x00	; 0
 1b8:	85 e1       	ldi	r24, 0x15	; 21
 1ba:	93 e0       	ldi	r25, 0x03	; 3
 1bc:	b9 01       	movw	r22, r18
 1be:	0e 94 10 02 	call	0x420	; 0x420 <EEPROM_readByte>

	while(UART_recieveByte()!= 13); /*loop until enter key is pressed @ MC1 keypad*/
 1c2:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 1c6:	8d 30       	cpi	r24, 0x0D	; 13
 1c8:	e1 f7       	brne	.-8      	; 0x1c2 <storePassCheck+0x76>
	/*check if password entered is matching with the stored on in EEPROM*/
	if(key1 != key11 || key2 != key22 || key3 != key33 || key4 != key44 || key5 != key55){
 1ca:	90 91 7b 00 	lds	r25, 0x007B
 1ce:	80 91 7a 00 	lds	r24, 0x007A
 1d2:	98 17       	cp	r25, r24
 1d4:	c1 f4       	brne	.+48     	; 0x206 <storePassCheck+0xba>
 1d6:	90 91 7e 00 	lds	r25, 0x007E
 1da:	80 91 7f 00 	lds	r24, 0x007F
 1de:	98 17       	cp	r25, r24
 1e0:	91 f4       	brne	.+36     	; 0x206 <storePassCheck+0xba>
 1e2:	90 91 7d 00 	lds	r25, 0x007D
 1e6:	80 91 78 00 	lds	r24, 0x0078
 1ea:	98 17       	cp	r25, r24
 1ec:	61 f4       	brne	.+24     	; 0x206 <storePassCheck+0xba>
 1ee:	90 91 76 00 	lds	r25, 0x0076
 1f2:	80 91 7c 00 	lds	r24, 0x007C
 1f6:	98 17       	cp	r25, r24
 1f8:	31 f4       	brne	.+12     	; 0x206 <storePassCheck+0xba>
 1fa:	90 91 77 00 	lds	r25, 0x0077
 1fe:	80 91 75 00 	lds	r24, 0x0075
 202:	98 17       	cp	r25, r24
 204:	21 f0       	breq	.+8      	; 0x20e <storePassCheck+0xc2>
		UART_sendByte(0x11); /*send byte to MC1 to confirm unmatched password*/
 206:	81 e1       	ldi	r24, 0x11	; 17
 208:	0e 94 1a 04 	call	0x834	; 0x834 <UART_sendByte>
 20c:	03 c0       	rjmp	.+6      	; 0x214 <storePassCheck+0xc8>
	}else{
		UART_sendByte(0x05); /*send byte to MC1 to confirm matched password*/
 20e:	85 e0       	ldi	r24, 0x05	; 5
 210:	0e 94 1a 04 	call	0x834	; 0x834 <UART_sendByte>
	}


}
 214:	cf 91       	pop	r28
 216:	df 91       	pop	r29
 218:	08 95       	ret

0000021a <rotateMotor>:

/*------------------------------------------------------------------------------
[Function Name]: rotateMotor
[Description]: rotate motor CW, CCW and stop
------------------------------------------------------------------------------*/
void rotateMotor(){
 21a:	df 93       	push	r29
 21c:	cf 93       	push	r28
 21e:	cd b7       	in	r28, 0x3d	; 61
 220:	de b7       	in	r29, 0x3e	; 62
 222:	3c c0       	rjmp	.+120    	; 0x29c <rotateMotor+0x82>
	while(motorStatus != 0x04){ /*loop until motor status equals finish operation*/
		motorStatus = UART_recieveByte();
 224:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 228:	80 93 6e 00 	sts	0x006E, r24
		//motorCount++;
		if(motorStatus == 0x01){ /*check if motorstatus is rotate CW*/
 22c:	80 91 6e 00 	lds	r24, 0x006E
 230:	81 30       	cpi	r24, 0x01	; 1
 232:	79 f4       	brne	.+30     	; 0x252 <rotateMotor+0x38>
			PORTD &= (~(1<<PD7));
 234:	a2 e3       	ldi	r26, 0x32	; 50
 236:	b0 e0       	ldi	r27, 0x00	; 0
 238:	e2 e3       	ldi	r30, 0x32	; 50
 23a:	f0 e0       	ldi	r31, 0x00	; 0
 23c:	80 81       	ld	r24, Z
 23e:	8f 77       	andi	r24, 0x7F	; 127
 240:	8c 93       	st	X, r24
			PORTD |= (1<<PD6);
 242:	a2 e3       	ldi	r26, 0x32	; 50
 244:	b0 e0       	ldi	r27, 0x00	; 0
 246:	e2 e3       	ldi	r30, 0x32	; 50
 248:	f0 e0       	ldi	r31, 0x00	; 0
 24a:	80 81       	ld	r24, Z
 24c:	80 64       	ori	r24, 0x40	; 64
 24e:	8c 93       	st	X, r24
 250:	25 c0       	rjmp	.+74     	; 0x29c <rotateMotor+0x82>
			//_delay_ms(4000);
		}else if(motorStatus == 0x02){ /*check if motorstatus is rotate CCW*/
 252:	80 91 6e 00 	lds	r24, 0x006E
 256:	82 30       	cpi	r24, 0x02	; 2
 258:	79 f4       	brne	.+30     	; 0x278 <rotateMotor+0x5e>
			PORTD &= (~(1<<PD6));
 25a:	a2 e3       	ldi	r26, 0x32	; 50
 25c:	b0 e0       	ldi	r27, 0x00	; 0
 25e:	e2 e3       	ldi	r30, 0x32	; 50
 260:	f0 e0       	ldi	r31, 0x00	; 0
 262:	80 81       	ld	r24, Z
 264:	8f 7b       	andi	r24, 0xBF	; 191
 266:	8c 93       	st	X, r24
			PORTD |= (1<<PD7);
 268:	a2 e3       	ldi	r26, 0x32	; 50
 26a:	b0 e0       	ldi	r27, 0x00	; 0
 26c:	e2 e3       	ldi	r30, 0x32	; 50
 26e:	f0 e0       	ldi	r31, 0x00	; 0
 270:	80 81       	ld	r24, Z
 272:	80 68       	ori	r24, 0x80	; 128
 274:	8c 93       	st	X, r24
 276:	12 c0       	rjmp	.+36     	; 0x29c <rotateMotor+0x82>
			//_delay_ms(4000);
		}else if(motorStatus == 0x03){ /*check if motorstatus is stop*/
 278:	80 91 6e 00 	lds	r24, 0x006E
 27c:	83 30       	cpi	r24, 0x03	; 3
 27e:	71 f4       	brne	.+28     	; 0x29c <rotateMotor+0x82>
			PORTD &= (~(1<<PD6));
 280:	a2 e3       	ldi	r26, 0x32	; 50
 282:	b0 e0       	ldi	r27, 0x00	; 0
 284:	e2 e3       	ldi	r30, 0x32	; 50
 286:	f0 e0       	ldi	r31, 0x00	; 0
 288:	80 81       	ld	r24, Z
 28a:	8f 7b       	andi	r24, 0xBF	; 191
 28c:	8c 93       	st	X, r24
			PORTD &= (~(1<<PD7));
 28e:	a2 e3       	ldi	r26, 0x32	; 50
 290:	b0 e0       	ldi	r27, 0x00	; 0
 292:	e2 e3       	ldi	r30, 0x32	; 50
 294:	f0 e0       	ldi	r31, 0x00	; 0
 296:	80 81       	ld	r24, Z
 298:	8f 77       	andi	r24, 0x7F	; 127
 29a:	8c 93       	st	X, r24
/*------------------------------------------------------------------------------
[Function Name]: rotateMotor
[Description]: rotate motor CW, CCW and stop
------------------------------------------------------------------------------*/
void rotateMotor(){
	while(motorStatus != 0x04){ /*loop until motor status equals finish operation*/
 29c:	80 91 6e 00 	lds	r24, 0x006E
 2a0:	84 30       	cpi	r24, 0x04	; 4
 2a2:	09 f0       	breq	.+2      	; 0x2a6 <rotateMotor+0x8c>
 2a4:	bf cf       	rjmp	.-130    	; 0x224 <rotateMotor+0xa>
			PORTD &= (~(1<<PD6));
			PORTD &= (~(1<<PD7));
			//_delay_ms(3000);
		}
	}
	motorStatus = 0x00; /*clear motorstatus for the next time*/
 2a6:	10 92 6e 00 	sts	0x006E, r1
	PORTD &= (~(1<<PD6));
 2aa:	a2 e3       	ldi	r26, 0x32	; 50
 2ac:	b0 e0       	ldi	r27, 0x00	; 0
 2ae:	e2 e3       	ldi	r30, 0x32	; 50
 2b0:	f0 e0       	ldi	r31, 0x00	; 0
 2b2:	80 81       	ld	r24, Z
 2b4:	8f 7b       	andi	r24, 0xBF	; 191
 2b6:	8c 93       	st	X, r24
	PORTD &= (~(1<<PD7));
 2b8:	a2 e3       	ldi	r26, 0x32	; 50
 2ba:	b0 e0       	ldi	r27, 0x00	; 0
 2bc:	e2 e3       	ldi	r30, 0x32	; 50
 2be:	f0 e0       	ldi	r31, 0x00	; 0
 2c0:	80 81       	ld	r24, Z
 2c2:	8f 77       	andi	r24, 0x7F	; 127
 2c4:	8c 93       	st	X, r24
}
 2c6:	cf 91       	pop	r28
 2c8:	df 91       	pop	r29
 2ca:	08 95       	ret

000002cc <buzzerStart>:

/*------------------------------------------------------------------------------
[Function Name]: buzzerStart
[Description]: start buzzer after the user entered the password 3 times wrong
------------------------------------------------------------------------------*/
void buzzerStart(){
 2cc:	df 93       	push	r29
 2ce:	cf 93       	push	r28
 2d0:	cd b7       	in	r28, 0x3d	; 61
 2d2:	de b7       	in	r29, 0x3e	; 62
	PORTC |= (1<<PC7);
 2d4:	a5 e3       	ldi	r26, 0x35	; 53
 2d6:	b0 e0       	ldi	r27, 0x00	; 0
 2d8:	e5 e3       	ldi	r30, 0x35	; 53
 2da:	f0 e0       	ldi	r31, 0x00	; 0
 2dc:	80 81       	ld	r24, Z
 2de:	80 68       	ori	r24, 0x80	; 128
 2e0:	8c 93       	st	X, r24
	timer0_init_normal_mode(&Timer0_Config); /*initialize timer0*/
 2e2:	80 e6       	ldi	r24, 0x60	; 96
 2e4:	90 e0       	ldi	r25, 0x00	; 0
 2e6:	0e 94 2c 03 	call	0x658	; 0x658 <timer0_init_normal_mode>
	while(buzzerFlag != 1); /*hold the buzzer until 60 seconds has passed*/
 2ea:	80 91 72 00 	lds	r24, 0x0072
 2ee:	81 30       	cpi	r24, 0x01	; 1
 2f0:	e1 f7       	brne	.-8      	; 0x2ea <buzzerStart+0x1e>
	buzzerFlag = 0; /*clear flag for the next time*/
 2f2:	10 92 72 00 	sts	0x0072, r1
	PORTC &= ~(1<<PC7);
 2f6:	a5 e3       	ldi	r26, 0x35	; 53
 2f8:	b0 e0       	ldi	r27, 0x00	; 0
 2fa:	e5 e3       	ldi	r30, 0x35	; 53
 2fc:	f0 e0       	ldi	r31, 0x00	; 0
 2fe:	80 81       	ld	r24, Z
 300:	8f 77       	andi	r24, 0x7F	; 127
 302:	8c 93       	st	X, r24
}
 304:	cf 91       	pop	r28
 306:	df 91       	pop	r29
 308:	08 95       	ret

0000030a <main>:

int main(){
 30a:	df 93       	push	r29
 30c:	cf 93       	push	r28
 30e:	cd b7       	in	r28, 0x3d	; 61
 310:	de b7       	in	r29, 0x3e	; 62
	DDRD |= (1<<PD6) | (1<<PD7); /*pin 6,7 PORTD output pins*/
 312:	a1 e3       	ldi	r26, 0x31	; 49
 314:	b0 e0       	ldi	r27, 0x00	; 0
 316:	e1 e3       	ldi	r30, 0x31	; 49
 318:	f0 e0       	ldi	r31, 0x00	; 0
 31a:	80 81       	ld	r24, Z
 31c:	80 6c       	ori	r24, 0xC0	; 192
 31e:	8c 93       	st	X, r24
	DDRC |= (1<<PC7); /*pin 7 PORTC output pin*/
 320:	a4 e3       	ldi	r26, 0x34	; 52
 322:	b0 e0       	ldi	r27, 0x00	; 0
 324:	e4 e3       	ldi	r30, 0x34	; 52
 326:	f0 e0       	ldi	r31, 0x00	; 0
 328:	80 81       	ld	r24, Z
 32a:	80 68       	ori	r24, 0x80	; 128
 32c:	8c 93       	st	X, r24
	timer0_setCallBack(timer_fn); /*set call back function for timer0*/
 32e:	89 e4       	ldi	r24, 0x49	; 73
 330:	90 e0       	ldi	r25, 0x00	; 0
 332:	0e 94 72 03 	call	0x6e4	; 0x6e4 <timer0_setCallBack>

	UART_init(&UART_config); /*initialize UART*/
 336:	84 e6       	ldi	r24, 0x64	; 100
 338:	90 e0       	ldi	r25, 0x00	; 0
 33a:	0e 94 84 03 	call	0x708	; 0x708 <UART_init>
	EEPROM_init(); /*initialize EEPROM*/
 33e:	0e 94 c4 01 	call	0x388	; 0x388 <EEPROM_init>
	while(1){ /*infinite loop*/
		/* 0x21 is for change password
		 * 0x20 is for check password
		 * 0x22 is for rotate motor
		 * 0x55 is for buzzerStart */
		receivedByte = UART_recieveByte();
 342:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 346:	80 93 79 00 	sts	0x0079, r24
		if(receivedByte == 0x21){
 34a:	80 91 79 00 	lds	r24, 0x0079
 34e:	81 32       	cpi	r24, 0x21	; 33
 350:	41 f4       	brne	.+16     	; 0x362 <main+0x58>
			storePassFirst();
 352:	0e 94 68 00 	call	0xd0	; 0xd0 <storePassFirst>
			while(UART_recieveByte()!= 13);
 356:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 35a:	8d 30       	cpi	r24, 0x0D	; 13
 35c:	e1 f7       	brne	.-8      	; 0x356 <main+0x4c>
			storePassCheck();
 35e:	0e 94 a6 00 	call	0x14c	; 0x14c <storePassCheck>
		}
		if(receivedByte == 0x20){
 362:	80 91 79 00 	lds	r24, 0x0079
 366:	80 32       	cpi	r24, 0x20	; 32
 368:	11 f4       	brne	.+4      	; 0x36e <main+0x64>
			storePassCheck();
 36a:	0e 94 a6 00 	call	0x14c	; 0x14c <storePassCheck>
		}
		if(receivedByte == 0x22){
 36e:	80 91 79 00 	lds	r24, 0x0079
 372:	82 32       	cpi	r24, 0x22	; 34
 374:	11 f4       	brne	.+4      	; 0x37a <main+0x70>
			rotateMotor();
 376:	0e 94 0d 01 	call	0x21a	; 0x21a <rotateMotor>
		}
		if(receivedByte == 0x55){
 37a:	80 91 79 00 	lds	r24, 0x0079
 37e:	85 35       	cpi	r24, 0x55	; 85
 380:	01 f7       	brne	.-64     	; 0x342 <main+0x38>
			buzzerStart();
 382:	0e 94 66 01 	call	0x2cc	; 0x2cc <buzzerStart>
 386:	dd cf       	rjmp	.-70     	; 0x342 <main+0x38>

00000388 <EEPROM_init>:
#include "external_eeprom.h"

I2C_ConfigType I2C_config = {0b00000010,0x02,ZERO_PRE};

void EEPROM_init(void)
{
 388:	df 93       	push	r29
 38a:	cf 93       	push	r28
 38c:	cd b7       	in	r28, 0x3d	; 61
 38e:	de b7       	in	r29, 0x3e	; 62
	/* just initialize the I2C(TWI) module inside the MC */
	TWI_init(&I2C_config);
 390:	8a e6       	ldi	r24, 0x6A	; 106
 392:	90 e0       	ldi	r25, 0x00	; 0
 394:	0e 94 70 02 	call	0x4e0	; 0x4e0 <TWI_init>
}
 398:	cf 91       	pop	r28
 39a:	df 91       	pop	r29
 39c:	08 95       	ret

0000039e <EEPROM_writeByte>:

uint8 EEPROM_writeByte(uint16 u16addr, uint8 u8data)
{
 39e:	df 93       	push	r29
 3a0:	cf 93       	push	r28
 3a2:	00 d0       	rcall	.+0      	; 0x3a4 <EEPROM_writeByte+0x6>
 3a4:	00 d0       	rcall	.+0      	; 0x3a6 <EEPROM_writeByte+0x8>
 3a6:	cd b7       	in	r28, 0x3d	; 61
 3a8:	de b7       	in	r29, 0x3e	; 62
 3aa:	9a 83       	std	Y+2, r25	; 0x02
 3ac:	89 83       	std	Y+1, r24	; 0x01
 3ae:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
 3b0:	0e 94 92 02 	call	0x524	; 0x524 <TWI_start>
    if (TWI_getStatus() != TW_START)
 3b4:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 3b8:	88 30       	cpi	r24, 0x08	; 8
 3ba:	11 f0       	breq	.+4      	; 0x3c0 <EEPROM_writeByte+0x22>
        return ERROR;
 3bc:	1c 82       	std	Y+4, r1	; 0x04
 3be:	28 c0       	rjmp	.+80     	; 0x410 <EEPROM_writeByte+0x72>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_write((uint8)(0xA0 | ((u16addr & 0x0700)>>7)));
 3c0:	89 81       	ldd	r24, Y+1	; 0x01
 3c2:	9a 81       	ldd	r25, Y+2	; 0x02
 3c4:	80 70       	andi	r24, 0x00	; 0
 3c6:	97 70       	andi	r25, 0x07	; 7
 3c8:	88 0f       	add	r24, r24
 3ca:	89 2f       	mov	r24, r25
 3cc:	88 1f       	adc	r24, r24
 3ce:	99 0b       	sbc	r25, r25
 3d0:	91 95       	neg	r25
 3d2:	80 6a       	ori	r24, 0xA0	; 160
 3d4:	0e 94 ad 02 	call	0x55a	; 0x55a <TWI_write>
    if (TWI_getStatus() != TW_MT_SLA_W_ACK)
 3d8:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 3dc:	88 31       	cpi	r24, 0x18	; 24
 3de:	11 f0       	breq	.+4      	; 0x3e4 <EEPROM_writeByte+0x46>
        return ERROR; 
 3e0:	1c 82       	std	Y+4, r1	; 0x04
 3e2:	16 c0       	rjmp	.+44     	; 0x410 <EEPROM_writeByte+0x72>
		 
    /* Send the required memory location address */
    TWI_write((uint8)(u16addr));
 3e4:	89 81       	ldd	r24, Y+1	; 0x01
 3e6:	0e 94 ad 02 	call	0x55a	; 0x55a <TWI_write>
    if (TWI_getStatus() != TW_MT_DATA_ACK)
 3ea:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 3ee:	88 32       	cpi	r24, 0x28	; 40
 3f0:	11 f0       	breq	.+4      	; 0x3f6 <EEPROM_writeByte+0x58>
        return ERROR;
 3f2:	1c 82       	std	Y+4, r1	; 0x04
 3f4:	0d c0       	rjmp	.+26     	; 0x410 <EEPROM_writeByte+0x72>
		
    /* write byte to eeprom */
    TWI_write(u8data);
 3f6:	8b 81       	ldd	r24, Y+3	; 0x03
 3f8:	0e 94 ad 02 	call	0x55a	; 0x55a <TWI_write>
    if (TWI_getStatus() != TW_MT_DATA_ACK)
 3fc:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 400:	88 32       	cpi	r24, 0x28	; 40
 402:	11 f0       	breq	.+4      	; 0x408 <EEPROM_writeByte+0x6a>
        return ERROR;
 404:	1c 82       	std	Y+4, r1	; 0x04
 406:	04 c0       	rjmp	.+8      	; 0x410 <EEPROM_writeByte+0x72>

    /* Send the Stop Bit */
    TWI_stop();
 408:	0e 94 a2 02 	call	0x544	; 0x544 <TWI_stop>
	
    return SUCCESS;
 40c:	81 e0       	ldi	r24, 0x01	; 1
 40e:	8c 83       	std	Y+4, r24	; 0x04
 410:	8c 81       	ldd	r24, Y+4	; 0x04
}
 412:	0f 90       	pop	r0
 414:	0f 90       	pop	r0
 416:	0f 90       	pop	r0
 418:	0f 90       	pop	r0
 41a:	cf 91       	pop	r28
 41c:	df 91       	pop	r29
 41e:	08 95       	ret

00000420 <EEPROM_readByte>:

uint8 EEPROM_readByte(uint16 u16addr, uint8 *u8data)
{
 420:	df 93       	push	r29
 422:	cf 93       	push	r28
 424:	00 d0       	rcall	.+0      	; 0x426 <EEPROM_readByte+0x6>
 426:	00 d0       	rcall	.+0      	; 0x428 <EEPROM_readByte+0x8>
 428:	0f 92       	push	r0
 42a:	cd b7       	in	r28, 0x3d	; 61
 42c:	de b7       	in	r29, 0x3e	; 62
 42e:	9a 83       	std	Y+2, r25	; 0x02
 430:	89 83       	std	Y+1, r24	; 0x01
 432:	7c 83       	std	Y+4, r23	; 0x04
 434:	6b 83       	std	Y+3, r22	; 0x03
	/* Send the Start Bit */
    TWI_start();
 436:	0e 94 92 02 	call	0x524	; 0x524 <TWI_start>
    if (TWI_getStatus() != TW_START)
 43a:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 43e:	88 30       	cpi	r24, 0x08	; 8
 440:	11 f0       	breq	.+4      	; 0x446 <EEPROM_readByte+0x26>
        return ERROR;
 442:	1d 82       	std	Y+5, r1	; 0x05
 444:	44 c0       	rjmp	.+136    	; 0x4ce <__stack+0x6f>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=0 (write) */
    TWI_write((uint8)((0xA0) | ((u16addr & 0x0700)>>7)));
 446:	89 81       	ldd	r24, Y+1	; 0x01
 448:	9a 81       	ldd	r25, Y+2	; 0x02
 44a:	80 70       	andi	r24, 0x00	; 0
 44c:	97 70       	andi	r25, 0x07	; 7
 44e:	88 0f       	add	r24, r24
 450:	89 2f       	mov	r24, r25
 452:	88 1f       	adc	r24, r24
 454:	99 0b       	sbc	r25, r25
 456:	91 95       	neg	r25
 458:	80 6a       	ori	r24, 0xA0	; 160
 45a:	0e 94 ad 02 	call	0x55a	; 0x55a <TWI_write>
    if (TWI_getStatus() != TW_MT_SLA_W_ACK)
 45e:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 462:	88 31       	cpi	r24, 0x18	; 24
 464:	11 f0       	breq	.+4      	; 0x46a <__stack+0xb>
        return ERROR;
 466:	1d 82       	std	Y+5, r1	; 0x05
 468:	32 c0       	rjmp	.+100    	; 0x4ce <__stack+0x6f>
		
    /* Send the required memory location address */
    TWI_write((uint8)(u16addr));
 46a:	89 81       	ldd	r24, Y+1	; 0x01
 46c:	0e 94 ad 02 	call	0x55a	; 0x55a <TWI_write>
    if (TWI_getStatus() != TW_MT_DATA_ACK)
 470:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 474:	88 32       	cpi	r24, 0x28	; 40
 476:	11 f0       	breq	.+4      	; 0x47c <__stack+0x1d>
        return ERROR;
 478:	1d 82       	std	Y+5, r1	; 0x05
 47a:	29 c0       	rjmp	.+82     	; 0x4ce <__stack+0x6f>
		
    /* Send the Repeated Start Bit */
    TWI_start();
 47c:	0e 94 92 02 	call	0x524	; 0x524 <TWI_start>
    if (TWI_getStatus() != TW_REP_START)
 480:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 484:	80 31       	cpi	r24, 0x10	; 16
 486:	11 f0       	breq	.+4      	; 0x48c <__stack+0x2d>
        return ERROR;
 488:	1d 82       	std	Y+5, r1	; 0x05
 48a:	21 c0       	rjmp	.+66     	; 0x4ce <__stack+0x6f>
		
    /* Send the device address, we need to get A8 A9 A10 address bits from the
     * memory location address and R/W=1 (Read) */
    TWI_write((uint8)((0xA0) | ((u16addr & 0x0700)>>7) | 1));
 48c:	89 81       	ldd	r24, Y+1	; 0x01
 48e:	9a 81       	ldd	r25, Y+2	; 0x02
 490:	80 70       	andi	r24, 0x00	; 0
 492:	97 70       	andi	r25, 0x07	; 7
 494:	88 0f       	add	r24, r24
 496:	89 2f       	mov	r24, r25
 498:	88 1f       	adc	r24, r24
 49a:	99 0b       	sbc	r25, r25
 49c:	91 95       	neg	r25
 49e:	81 6a       	ori	r24, 0xA1	; 161
 4a0:	0e 94 ad 02 	call	0x55a	; 0x55a <TWI_write>
    if (TWI_getStatus() != TW_MT_SLA_R_ACK)
 4a4:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 4a8:	80 34       	cpi	r24, 0x40	; 64
 4aa:	11 f0       	breq	.+4      	; 0x4b0 <__stack+0x51>
        return ERROR;
 4ac:	1d 82       	std	Y+5, r1	; 0x05
 4ae:	0f c0       	rjmp	.+30     	; 0x4ce <__stack+0x6f>

    /* Read Byte from Memory without send ACK */
    *u8data = TWI_readWithNACK();
 4b0:	0e 94 d7 02 	call	0x5ae	; 0x5ae <TWI_readWithNACK>
 4b4:	eb 81       	ldd	r30, Y+3	; 0x03
 4b6:	fc 81       	ldd	r31, Y+4	; 0x04
 4b8:	80 83       	st	Z, r24
    if (TWI_getStatus() != TW_MR_DATA_NACK)
 4ba:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <TWI_getStatus>
 4be:	88 35       	cpi	r24, 0x58	; 88
 4c0:	11 f0       	breq	.+4      	; 0x4c6 <__stack+0x67>
        return ERROR;
 4c2:	1d 82       	std	Y+5, r1	; 0x05
 4c4:	04 c0       	rjmp	.+8      	; 0x4ce <__stack+0x6f>

    /* Send the Stop Bit */
    TWI_stop();
 4c6:	0e 94 a2 02 	call	0x544	; 0x544 <TWI_stop>
    return SUCCESS;
 4ca:	81 e0       	ldi	r24, 0x01	; 1
 4cc:	8d 83       	std	Y+5, r24	; 0x05
 4ce:	8d 81       	ldd	r24, Y+5	; 0x05
}
 4d0:	0f 90       	pop	r0
 4d2:	0f 90       	pop	r0
 4d4:	0f 90       	pop	r0
 4d6:	0f 90       	pop	r0
 4d8:	0f 90       	pop	r0
 4da:	cf 91       	pop	r28
 4dc:	df 91       	pop	r29
 4de:	08 95       	ret

000004e0 <TWI_init>:
 *******************************************************************************/
 
#include "i2c.h"

void TWI_init(const I2C_ConfigType * I2C_ConfigPtr)
{
 4e0:	df 93       	push	r29
 4e2:	cf 93       	push	r28
 4e4:	00 d0       	rcall	.+0      	; 0x4e6 <TWI_init+0x6>
 4e6:	cd b7       	in	r28, 0x3d	; 61
 4e8:	de b7       	in	r29, 0x3e	; 62
 4ea:	9a 83       	std	Y+2, r25	; 0x02
 4ec:	89 83       	std	Y+1, r24	; 0x01
    /* Bit Rate: 400.000 kbps using zero pre-scaler TWPS=00 and F_CPU=8Mhz */
    //TWBR = 0x02;
	TWBR = I2C_ConfigPtr->bitRate;
 4ee:	a0 e2       	ldi	r26, 0x20	; 32
 4f0:	b0 e0       	ldi	r27, 0x00	; 0
 4f2:	e9 81       	ldd	r30, Y+1	; 0x01
 4f4:	fa 81       	ldd	r31, Y+2	; 0x02
 4f6:	81 81       	ldd	r24, Z+1	; 0x01
 4f8:	8c 93       	st	X, r24
	//TWSR = 0x00;
	TWSR = I2C_ConfigPtr->prescale;
 4fa:	a1 e2       	ldi	r26, 0x21	; 33
 4fc:	b0 e0       	ldi	r27, 0x00	; 0
 4fe:	e9 81       	ldd	r30, Y+1	; 0x01
 500:	fa 81       	ldd	r31, Y+2	; 0x02
 502:	82 81       	ldd	r24, Z+2	; 0x02
 504:	8c 93       	st	X, r24

    /* Two Wire Bus address my address if any master device want to call me: 0x1 (used in case this MC is a slave device)
       General Call Recognition: Off */
    //TWAR = 0b00000010; // my address = 0x01 :)
	TWAR = I2C_ConfigPtr->Address;
 506:	a2 e2       	ldi	r26, 0x22	; 34
 508:	b0 e0       	ldi	r27, 0x00	; 0
 50a:	e9 81       	ldd	r30, Y+1	; 0x01
 50c:	fa 81       	ldd	r31, Y+2	; 0x02
 50e:	80 81       	ld	r24, Z
 510:	8c 93       	st	X, r24
	
    TWCR = (1<<TWEN); /* enable TWI */
 512:	e6 e5       	ldi	r30, 0x56	; 86
 514:	f0 e0       	ldi	r31, 0x00	; 0
 516:	84 e0       	ldi	r24, 0x04	; 4
 518:	80 83       	st	Z, r24
}
 51a:	0f 90       	pop	r0
 51c:	0f 90       	pop	r0
 51e:	cf 91       	pop	r28
 520:	df 91       	pop	r29
 522:	08 95       	ret

00000524 <TWI_start>:

void TWI_start(void)
{
 524:	df 93       	push	r29
 526:	cf 93       	push	r28
 528:	cd b7       	in	r28, 0x3d	; 61
 52a:	de b7       	in	r29, 0x3e	; 62
    /* 
	 * Clear the TWINT flag before sending the start bit TWINT=1
	 * send the start bit by TWSTA=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTA) | (1 << TWEN);
 52c:	e6 e5       	ldi	r30, 0x56	; 86
 52e:	f0 e0       	ldi	r31, 0x00	; 0
 530:	84 ea       	ldi	r24, 0xA4	; 164
 532:	80 83       	st	Z, r24
    
    /* Wait for TWINT flag set in TWCR Register (start bit is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
 534:	e6 e5       	ldi	r30, 0x56	; 86
 536:	f0 e0       	ldi	r31, 0x00	; 0
 538:	80 81       	ld	r24, Z
 53a:	88 23       	and	r24, r24
 53c:	dc f7       	brge	.-10     	; 0x534 <TWI_start+0x10>
}
 53e:	cf 91       	pop	r28
 540:	df 91       	pop	r29
 542:	08 95       	ret

00000544 <TWI_stop>:

void TWI_stop(void)
{
 544:	df 93       	push	r29
 546:	cf 93       	push	r28
 548:	cd b7       	in	r28, 0x3d	; 61
 54a:	de b7       	in	r29, 0x3e	; 62
    /* 
	 * Clear the TWINT flag before sending the stop bit TWINT=1
	 * send the stop bit by TWSTO=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWSTO) | (1 << TWEN);
 54c:	e6 e5       	ldi	r30, 0x56	; 86
 54e:	f0 e0       	ldi	r31, 0x00	; 0
 550:	84 e9       	ldi	r24, 0x94	; 148
 552:	80 83       	st	Z, r24
}
 554:	cf 91       	pop	r28
 556:	df 91       	pop	r29
 558:	08 95       	ret

0000055a <TWI_write>:

void TWI_write(uint8 data)
{
 55a:	df 93       	push	r29
 55c:	cf 93       	push	r28
 55e:	0f 92       	push	r0
 560:	cd b7       	in	r28, 0x3d	; 61
 562:	de b7       	in	r29, 0x3e	; 62
 564:	89 83       	std	Y+1, r24	; 0x01
    /* Put data On TWI data Register */
    TWDR = data;
 566:	e3 e2       	ldi	r30, 0x23	; 35
 568:	f0 e0       	ldi	r31, 0x00	; 0
 56a:	89 81       	ldd	r24, Y+1	; 0x01
 56c:	80 83       	st	Z, r24
    /* 
	 * Clear the TWINT flag before sending the data TWINT=1
	 * Enable TWI Module TWEN=1 
	 */ 
    TWCR = (1 << TWINT) | (1 << TWEN);
 56e:	e6 e5       	ldi	r30, 0x56	; 86
 570:	f0 e0       	ldi	r31, 0x00	; 0
 572:	84 e8       	ldi	r24, 0x84	; 132
 574:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register(data is send successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
 576:	e6 e5       	ldi	r30, 0x56	; 86
 578:	f0 e0       	ldi	r31, 0x00	; 0
 57a:	80 81       	ld	r24, Z
 57c:	88 23       	and	r24, r24
 57e:	dc f7       	brge	.-10     	; 0x576 <TWI_write+0x1c>
}
 580:	0f 90       	pop	r0
 582:	cf 91       	pop	r28
 584:	df 91       	pop	r29
 586:	08 95       	ret

00000588 <TWI_readWithACK>:

uint8 TWI_readWithACK(void)
{
 588:	df 93       	push	r29
 58a:	cf 93       	push	r28
 58c:	cd b7       	in	r28, 0x3d	; 61
 58e:	de b7       	in	r29, 0x3e	; 62
	/* 
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable sending ACK after reading or receiving data TWEA=1
	 * Enable TWI Module TWEN=1 
	 */ 
    TWCR = (1 << TWINT) | (1 << TWEN) | (1 << TWEA);
 590:	e6 e5       	ldi	r30, 0x56	; 86
 592:	f0 e0       	ldi	r31, 0x00	; 0
 594:	84 ec       	ldi	r24, 0xC4	; 196
 596:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
 598:	e6 e5       	ldi	r30, 0x56	; 86
 59a:	f0 e0       	ldi	r31, 0x00	; 0
 59c:	80 81       	ld	r24, Z
 59e:	88 23       	and	r24, r24
 5a0:	dc f7       	brge	.-10     	; 0x598 <TWI_readWithACK+0x10>
    /* Read Data */
    return TWDR;
 5a2:	e3 e2       	ldi	r30, 0x23	; 35
 5a4:	f0 e0       	ldi	r31, 0x00	; 0
 5a6:	80 81       	ld	r24, Z
}
 5a8:	cf 91       	pop	r28
 5aa:	df 91       	pop	r29
 5ac:	08 95       	ret

000005ae <TWI_readWithNACK>:

uint8 TWI_readWithNACK(void)
{
 5ae:	df 93       	push	r29
 5b0:	cf 93       	push	r28
 5b2:	cd b7       	in	r28, 0x3d	; 61
 5b4:	de b7       	in	r29, 0x3e	; 62
	/* 
	 * Clear the TWINT flag before reading the data TWINT=1
	 * Enable TWI Module TWEN=1 
	 */
    TWCR = (1 << TWINT) | (1 << TWEN);
 5b6:	e6 e5       	ldi	r30, 0x56	; 86
 5b8:	f0 e0       	ldi	r31, 0x00	; 0
 5ba:	84 e8       	ldi	r24, 0x84	; 132
 5bc:	80 83       	st	Z, r24
    /* Wait for TWINT flag set in TWCR Register (data received successfully) */
    while(BIT_IS_CLEAR(TWCR,TWINT));
 5be:	e6 e5       	ldi	r30, 0x56	; 86
 5c0:	f0 e0       	ldi	r31, 0x00	; 0
 5c2:	80 81       	ld	r24, Z
 5c4:	88 23       	and	r24, r24
 5c6:	dc f7       	brge	.-10     	; 0x5be <TWI_readWithNACK+0x10>
    /* Read Data */
    return TWDR;
 5c8:	e3 e2       	ldi	r30, 0x23	; 35
 5ca:	f0 e0       	ldi	r31, 0x00	; 0
 5cc:	80 81       	ld	r24, Z
}
 5ce:	cf 91       	pop	r28
 5d0:	df 91       	pop	r29
 5d2:	08 95       	ret

000005d4 <TWI_getStatus>:

uint8 TWI_getStatus(void)
{
 5d4:	df 93       	push	r29
 5d6:	cf 93       	push	r28
 5d8:	0f 92       	push	r0
 5da:	cd b7       	in	r28, 0x3d	; 61
 5dc:	de b7       	in	r29, 0x3e	; 62
    uint8 status;
    /* masking to eliminate first 3 bits and get the last 5 bits (status bits) */
    status = TWSR & 0xF8;
 5de:	e1 e2       	ldi	r30, 0x21	; 33
 5e0:	f0 e0       	ldi	r31, 0x00	; 0
 5e2:	80 81       	ld	r24, Z
 5e4:	88 7f       	andi	r24, 0xF8	; 248
 5e6:	89 83       	std	Y+1, r24	; 0x01
    return status;
 5e8:	89 81       	ldd	r24, Y+1	; 0x01
}
 5ea:	0f 90       	pop	r0
 5ec:	cf 91       	pop	r28
 5ee:	df 91       	pop	r29
 5f0:	08 95       	ret

000005f2 <__vector_9>:
#include "timer0.h"

static volatile void (*g_callBackPtr)(void) = NULL_PTR;

ISR(TIMER0_OVF_vect)
{
 5f2:	1f 92       	push	r1
 5f4:	0f 92       	push	r0
 5f6:	0f b6       	in	r0, 0x3f	; 63
 5f8:	0f 92       	push	r0
 5fa:	11 24       	eor	r1, r1
 5fc:	2f 93       	push	r18
 5fe:	3f 93       	push	r19
 600:	4f 93       	push	r20
 602:	5f 93       	push	r21
 604:	6f 93       	push	r22
 606:	7f 93       	push	r23
 608:	8f 93       	push	r24
 60a:	9f 93       	push	r25
 60c:	af 93       	push	r26
 60e:	bf 93       	push	r27
 610:	ef 93       	push	r30
 612:	ff 93       	push	r31
 614:	df 93       	push	r29
 616:	cf 93       	push	r28
 618:	cd b7       	in	r28, 0x3d	; 61
 61a:	de b7       	in	r29, 0x3e	; 62
	if(g_callBackPtr != NULL_PTR)
 61c:	80 91 73 00 	lds	r24, 0x0073
 620:	90 91 74 00 	lds	r25, 0x0074
 624:	00 97       	sbiw	r24, 0x00	; 0
 626:	29 f0       	breq	.+10     	; 0x632 <__vector_9+0x40>
	{
		/* Call the Call Back function in the application after the edge is detected */
		(*g_callBackPtr)(); /* another method to call the function using pointer to function g_callBackPtr(); */
 628:	e0 91 73 00 	lds	r30, 0x0073
 62c:	f0 91 74 00 	lds	r31, 0x0074
 630:	09 95       	icall
	}
}
 632:	cf 91       	pop	r28
 634:	df 91       	pop	r29
 636:	ff 91       	pop	r31
 638:	ef 91       	pop	r30
 63a:	bf 91       	pop	r27
 63c:	af 91       	pop	r26
 63e:	9f 91       	pop	r25
 640:	8f 91       	pop	r24
 642:	7f 91       	pop	r23
 644:	6f 91       	pop	r22
 646:	5f 91       	pop	r21
 648:	4f 91       	pop	r20
 64a:	3f 91       	pop	r19
 64c:	2f 91       	pop	r18
 64e:	0f 90       	pop	r0
 650:	0f be       	out	0x3f, r0	; 63
 652:	0f 90       	pop	r0
 654:	1f 90       	pop	r1
 656:	18 95       	reti

00000658 <timer0_init_normal_mode>:

void timer0_init_normal_mode(const Timer0_ConfigType * Timer0_ConfigPtr)
{
 658:	df 93       	push	r29
 65a:	cf 93       	push	r28
 65c:	00 d0       	rcall	.+0      	; 0x65e <timer0_init_normal_mode+0x6>
 65e:	cd b7       	in	r28, 0x3d	; 61
 660:	de b7       	in	r29, 0x3e	; 62
 662:	9a 83       	std	Y+2, r25	; 0x02
 664:	89 83       	std	Y+1, r24	; 0x01
	TCNT0 = Timer0_ConfigPtr->initialValue; //Set Timer initial value to 0
 666:	a2 e5       	ldi	r26, 0x52	; 82
 668:	b0 e0       	ldi	r27, 0x00	; 0
 66a:	e9 81       	ldd	r30, Y+1	; 0x01
 66c:	fa 81       	ldd	r31, Y+2	; 0x02
 66e:	80 81       	ld	r24, Z
 670:	8c 93       	st	X, r24
	OCR0 = Timer0_ConfigPtr->compareValue;
 672:	ac e5       	ldi	r26, 0x5C	; 92
 674:	b0 e0       	ldi	r27, 0x00	; 0
 676:	e9 81       	ldd	r30, Y+1	; 0x01
 678:	fa 81       	ldd	r31, Y+2	; 0x02
 67a:	81 81       	ldd	r24, Z+1	; 0x01
 67c:	8c 93       	st	X, r24
	TIMSK |= (1<<TOIE0); // Enable Timer0 Overflow Interrupt
 67e:	a9 e5       	ldi	r26, 0x59	; 89
 680:	b0 e0       	ldi	r27, 0x00	; 0
 682:	e9 e5       	ldi	r30, 0x59	; 89
 684:	f0 e0       	ldi	r31, 0x00	; 0
 686:	80 81       	ld	r24, Z
 688:	81 60       	ori	r24, 0x01	; 1
 68a:	8c 93       	st	X, r24
	 * 2. Normal Mode WGM01=0 & WGM00=0
	 * 3. Normal Mode COM00=0 & COM01=0
	 * 4. clock = F_CPU/1024 CS00=1 CS01=0 CS02=1
	 */
	//TCCR0 = (1<<FOC0) | (1<<CS02) | (1<<CS00);
	TCCR0 = (TCCR0 & 0b00000111) | ((Timer0_ConfigPtr->mode)<<3);
 68c:	a3 e5       	ldi	r26, 0x53	; 83
 68e:	b0 e0       	ldi	r27, 0x00	; 0
 690:	e3 e5       	ldi	r30, 0x53	; 83
 692:	f0 e0       	ldi	r31, 0x00	; 0
 694:	80 81       	ld	r24, Z
 696:	28 2f       	mov	r18, r24
 698:	27 70       	andi	r18, 0x07	; 7
 69a:	e9 81       	ldd	r30, Y+1	; 0x01
 69c:	fa 81       	ldd	r31, Y+2	; 0x02
 69e:	82 81       	ldd	r24, Z+2	; 0x02
 6a0:	88 2f       	mov	r24, r24
 6a2:	90 e0       	ldi	r25, 0x00	; 0
 6a4:	88 0f       	add	r24, r24
 6a6:	99 1f       	adc	r25, r25
 6a8:	88 0f       	add	r24, r24
 6aa:	99 1f       	adc	r25, r25
 6ac:	88 0f       	add	r24, r24
 6ae:	99 1f       	adc	r25, r25
 6b0:	82 2b       	or	r24, r18
 6b2:	8c 93       	st	X, r24
	TCCR0 = (TCCR0 & 0b11111000) | (Timer0_ConfigPtr->prescale);
 6b4:	a3 e5       	ldi	r26, 0x53	; 83
 6b6:	b0 e0       	ldi	r27, 0x00	; 0
 6b8:	e3 e5       	ldi	r30, 0x53	; 83
 6ba:	f0 e0       	ldi	r31, 0x00	; 0
 6bc:	80 81       	ld	r24, Z
 6be:	98 2f       	mov	r25, r24
 6c0:	98 7f       	andi	r25, 0xF8	; 248
 6c2:	e9 81       	ldd	r30, Y+1	; 0x01
 6c4:	fa 81       	ldd	r31, Y+2	; 0x02
 6c6:	83 81       	ldd	r24, Z+3	; 0x03
 6c8:	89 2b       	or	r24, r25
 6ca:	8c 93       	st	X, r24
	SREG  |= (1<<7);
 6cc:	af e5       	ldi	r26, 0x5F	; 95
 6ce:	b0 e0       	ldi	r27, 0x00	; 0
 6d0:	ef e5       	ldi	r30, 0x5F	; 95
 6d2:	f0 e0       	ldi	r31, 0x00	; 0
 6d4:	80 81       	ld	r24, Z
 6d6:	80 68       	ori	r24, 0x80	; 128
 6d8:	8c 93       	st	X, r24
}
 6da:	0f 90       	pop	r0
 6dc:	0f 90       	pop	r0
 6de:	cf 91       	pop	r28
 6e0:	df 91       	pop	r29
 6e2:	08 95       	ret

000006e4 <timer0_setCallBack>:

void timer0_setCallBack(void(*a_ptr)(void))
{
 6e4:	df 93       	push	r29
 6e6:	cf 93       	push	r28
 6e8:	00 d0       	rcall	.+0      	; 0x6ea <timer0_setCallBack+0x6>
 6ea:	cd b7       	in	r28, 0x3d	; 61
 6ec:	de b7       	in	r29, 0x3e	; 62
 6ee:	9a 83       	std	Y+2, r25	; 0x02
 6f0:	89 83       	std	Y+1, r24	; 0x01
	/* Save the address of the Call back function in a global variable */
	g_callBackPtr = a_ptr;
 6f2:	89 81       	ldd	r24, Y+1	; 0x01
 6f4:	9a 81       	ldd	r25, Y+2	; 0x02
 6f6:	90 93 74 00 	sts	0x0074, r25
 6fa:	80 93 73 00 	sts	0x0073, r24
}
 6fe:	0f 90       	pop	r0
 700:	0f 90       	pop	r0
 702:	cf 91       	pop	r28
 704:	df 91       	pop	r29
 706:	08 95       	ret

00000708 <UART_init>:

/*******************************************************************************
 *                      Functions Definitions                                  *
 *******************************************************************************/
void UART_init(const UART_ConfigType * UART_ConfigPtr)
{
 708:	df 93       	push	r29
 70a:	cf 93       	push	r28
 70c:	00 d0       	rcall	.+0      	; 0x70e <UART_init+0x6>
 70e:	cd b7       	in	r28, 0x3d	; 61
 710:	de b7       	in	r29, 0x3e	; 62
 712:	9a 83       	std	Y+2, r25	; 0x02
 714:	89 83       	std	Y+1, r24	; 0x01
	/* U2X = 1 for double transmission speed */
	UCSRA = (1<<U2X);
 716:	eb e2       	ldi	r30, 0x2B	; 43
 718:	f0 e0       	ldi	r31, 0x00	; 0
 71a:	82 e0       	ldi	r24, 0x02	; 2
 71c:	80 83       	st	Z, r24
	 * RXEN  = 1 Receiver Enable
	 * RXEN  = 1 Transmitter Enable
	 * UCSZ2 = 0 For 8-bit data mode
	 * RXB8 & TXB8 not used for 8-bit data mode
	 ***********************************************************************/ 
	UCSRB = (1<<RXEN) | (1<<TXEN);
 71e:	ea e2       	ldi	r30, 0x2A	; 42
 720:	f0 e0       	ldi	r31, 0x00	; 0
 722:	88 e1       	ldi	r24, 0x18	; 24
 724:	80 83       	st	Z, r24
	UCSRB = (UCSRB & 0b11111011) | ((UART_ConfigPtr->UCSZ_2)<<2); //Bits data
 726:	aa e2       	ldi	r26, 0x2A	; 42
 728:	b0 e0       	ldi	r27, 0x00	; 0
 72a:	ea e2       	ldi	r30, 0x2A	; 42
 72c:	f0 e0       	ldi	r31, 0x00	; 0
 72e:	80 81       	ld	r24, Z
 730:	28 2f       	mov	r18, r24
 732:	2b 7f       	andi	r18, 0xFB	; 251
 734:	e9 81       	ldd	r30, Y+1	; 0x01
 736:	fa 81       	ldd	r31, Y+2	; 0x02
 738:	85 81       	ldd	r24, Z+5	; 0x05
 73a:	88 2f       	mov	r24, r24
 73c:	90 e0       	ldi	r25, 0x00	; 0
 73e:	88 0f       	add	r24, r24
 740:	99 1f       	adc	r25, r25
 742:	88 0f       	add	r24, r24
 744:	99 1f       	adc	r25, r25
 746:	82 2b       	or	r24, r18
 748:	8c 93       	st	X, r24
	 * USBS    = 0 One stop bit
	 * UCSZ1:0 = 11 For 8-bit data mode
	 * UCPOL   = 0 Used with the Synchronous operation only
	 ***********************************************************************/ 	
	//UCSRC = (1<<URSEL) | (1<<UCSZ0) | (1<<UCSZ1);
	UCSRC = (1<<URSEL);
 74a:	e0 e4       	ldi	r30, 0x40	; 64
 74c:	f0 e0       	ldi	r31, 0x00	; 0
 74e:	80 e8       	ldi	r24, 0x80	; 128
 750:	80 83       	st	Z, r24
	UCSRC = (UCSRC & 0b11001111) | ((UART_ConfigPtr->parityMode)<<4); //parity
 752:	a0 e4       	ldi	r26, 0x40	; 64
 754:	b0 e0       	ldi	r27, 0x00	; 0
 756:	e0 e4       	ldi	r30, 0x40	; 64
 758:	f0 e0       	ldi	r31, 0x00	; 0
 75a:	80 81       	ld	r24, Z
 75c:	28 2f       	mov	r18, r24
 75e:	2f 7c       	andi	r18, 0xCF	; 207
 760:	e9 81       	ldd	r30, Y+1	; 0x01
 762:	fa 81       	ldd	r31, Y+2	; 0x02
 764:	82 81       	ldd	r24, Z+2	; 0x02
 766:	88 2f       	mov	r24, r24
 768:	90 e0       	ldi	r25, 0x00	; 0
 76a:	82 95       	swap	r24
 76c:	92 95       	swap	r25
 76e:	90 7f       	andi	r25, 0xF0	; 240
 770:	98 27       	eor	r25, r24
 772:	80 7f       	andi	r24, 0xF0	; 240
 774:	98 27       	eor	r25, r24
 776:	82 2b       	or	r24, r18
 778:	8c 93       	st	X, r24
	UCSRC = (UCSRC & 0b11110111) | ((UART_ConfigPtr->stopBits)<<3); //stopBits
 77a:	a0 e4       	ldi	r26, 0x40	; 64
 77c:	b0 e0       	ldi	r27, 0x00	; 0
 77e:	e0 e4       	ldi	r30, 0x40	; 64
 780:	f0 e0       	ldi	r31, 0x00	; 0
 782:	80 81       	ld	r24, Z
 784:	28 2f       	mov	r18, r24
 786:	27 7f       	andi	r18, 0xF7	; 247
 788:	e9 81       	ldd	r30, Y+1	; 0x01
 78a:	fa 81       	ldd	r31, Y+2	; 0x02
 78c:	83 81       	ldd	r24, Z+3	; 0x03
 78e:	88 2f       	mov	r24, r24
 790:	90 e0       	ldi	r25, 0x00	; 0
 792:	88 0f       	add	r24, r24
 794:	99 1f       	adc	r25, r25
 796:	88 0f       	add	r24, r24
 798:	99 1f       	adc	r25, r25
 79a:	88 0f       	add	r24, r24
 79c:	99 1f       	adc	r25, r25
 79e:	82 2b       	or	r24, r18
 7a0:	8c 93       	st	X, r24
	UCSRC = (UCSRC & 0b11111001) | ((UART_ConfigPtr->UCSZ_1_0)<<1); //Bits data
 7a2:	a0 e4       	ldi	r26, 0x40	; 64
 7a4:	b0 e0       	ldi	r27, 0x00	; 0
 7a6:	e0 e4       	ldi	r30, 0x40	; 64
 7a8:	f0 e0       	ldi	r31, 0x00	; 0
 7aa:	80 81       	ld	r24, Z
 7ac:	28 2f       	mov	r18, r24
 7ae:	29 7f       	andi	r18, 0xF9	; 249
 7b0:	e9 81       	ldd	r30, Y+1	; 0x01
 7b2:	fa 81       	ldd	r31, Y+2	; 0x02
 7b4:	84 81       	ldd	r24, Z+4	; 0x04
 7b6:	88 2f       	mov	r24, r24
 7b8:	90 e0       	ldi	r25, 0x00	; 0
 7ba:	88 0f       	add	r24, r24
 7bc:	99 1f       	adc	r25, r25
 7be:	82 2b       	or	r24, r18
 7c0:	8c 93       	st	X, r24

	/* First 8 bits from the BAUD_PRESCALE inside UBRRL and last 4 bits in UBRRH*/
	BAUD_PRESCALE = (((8000000 / ((UART_ConfigPtr->baudRate) * 8UL))) - 1);
 7c2:	e9 81       	ldd	r30, Y+1	; 0x01
 7c4:	fa 81       	ldd	r31, Y+2	; 0x02
 7c6:	80 81       	ld	r24, Z
 7c8:	91 81       	ldd	r25, Z+1	; 0x01
 7ca:	cc 01       	movw	r24, r24
 7cc:	a0 e0       	ldi	r26, 0x00	; 0
 7ce:	b0 e0       	ldi	r27, 0x00	; 0
 7d0:	88 0f       	add	r24, r24
 7d2:	99 1f       	adc	r25, r25
 7d4:	aa 1f       	adc	r26, r26
 7d6:	bb 1f       	adc	r27, r27
 7d8:	88 0f       	add	r24, r24
 7da:	99 1f       	adc	r25, r25
 7dc:	aa 1f       	adc	r26, r26
 7de:	bb 1f       	adc	r27, r27
 7e0:	88 0f       	add	r24, r24
 7e2:	99 1f       	adc	r25, r25
 7e4:	aa 1f       	adc	r26, r26
 7e6:	bb 1f       	adc	r27, r27
 7e8:	9c 01       	movw	r18, r24
 7ea:	ad 01       	movw	r20, r26
 7ec:	80 e0       	ldi	r24, 0x00	; 0
 7ee:	92 e1       	ldi	r25, 0x12	; 18
 7f0:	aa e7       	ldi	r26, 0x7A	; 122
 7f2:	b0 e0       	ldi	r27, 0x00	; 0
 7f4:	bc 01       	movw	r22, r24
 7f6:	cd 01       	movw	r24, r26
 7f8:	0e 94 ac 04 	call	0x958	; 0x958 <__udivmodsi4>
 7fc:	da 01       	movw	r26, r20
 7fe:	c9 01       	movw	r24, r18
 800:	01 97       	sbiw	r24, 0x01	; 1
 802:	90 93 81 00 	sts	0x0081, r25
 806:	80 93 80 00 	sts	0x0080, r24
	UBRRH = BAUD_PRESCALE>>8;
 80a:	e0 e4       	ldi	r30, 0x40	; 64
 80c:	f0 e0       	ldi	r31, 0x00	; 0
 80e:	80 91 80 00 	lds	r24, 0x0080
 812:	90 91 81 00 	lds	r25, 0x0081
 816:	89 2f       	mov	r24, r25
 818:	99 27       	eor	r25, r25
 81a:	80 83       	st	Z, r24
	UBRRL = BAUD_PRESCALE;
 81c:	e9 e2       	ldi	r30, 0x29	; 41
 81e:	f0 e0       	ldi	r31, 0x00	; 0
 820:	80 91 80 00 	lds	r24, 0x0080
 824:	90 91 81 00 	lds	r25, 0x0081
 828:	80 83       	st	Z, r24
}
 82a:	0f 90       	pop	r0
 82c:	0f 90       	pop	r0
 82e:	cf 91       	pop	r28
 830:	df 91       	pop	r29
 832:	08 95       	ret

00000834 <UART_sendByte>:
	
void UART_sendByte(const uint8 data)
{
 834:	df 93       	push	r29
 836:	cf 93       	push	r28
 838:	0f 92       	push	r0
 83a:	cd b7       	in	r28, 0x3d	; 61
 83c:	de b7       	in	r29, 0x3e	; 62
 83e:	89 83       	std	Y+1, r24	; 0x01
	/* UDRE flag is set when the Tx buffer (UDR) is empty and ready for 
	 * transmitting a new byte so wait until this flag is set to one */
	while(BIT_IS_CLEAR(UCSRA,UDRE)){}
 840:	eb e2       	ldi	r30, 0x2B	; 43
 842:	f0 e0       	ldi	r31, 0x00	; 0
 844:	80 81       	ld	r24, Z
 846:	88 2f       	mov	r24, r24
 848:	90 e0       	ldi	r25, 0x00	; 0
 84a:	80 72       	andi	r24, 0x20	; 32
 84c:	90 70       	andi	r25, 0x00	; 0
 84e:	00 97       	sbiw	r24, 0x00	; 0
 850:	b9 f3       	breq	.-18     	; 0x840 <UART_sendByte+0xc>
	/* Put the required data in the UDR register and it also clear the UDRE flag as 
	 * the UDR register is not empty now */	 
	UDR = data;
 852:	ec e2       	ldi	r30, 0x2C	; 44
 854:	f0 e0       	ldi	r31, 0x00	; 0
 856:	89 81       	ldd	r24, Y+1	; 0x01
 858:	80 83       	st	Z, r24
	/************************* Another Method *************************
	UDR = data;
	while(BIT_IS_CLEAR(UCSRA,TXC)){} // Wait until the transimission is complete TXC = 1
	SET_BIT(UCSRA,TXC); // Clear the TXC flag
	*******************************************************************/	
}
 85a:	0f 90       	pop	r0
 85c:	cf 91       	pop	r28
 85e:	df 91       	pop	r29
 860:	08 95       	ret

00000862 <UART_recieveByte>:

uint8 UART_recieveByte(void)
{
 862:	df 93       	push	r29
 864:	cf 93       	push	r28
 866:	cd b7       	in	r28, 0x3d	; 61
 868:	de b7       	in	r29, 0x3e	; 62
	/* RXC flag is set when the UART receive data so wait until this 
	 * flag is set to one */
	while(BIT_IS_CLEAR(UCSRA,RXC)){}
 86a:	eb e2       	ldi	r30, 0x2B	; 43
 86c:	f0 e0       	ldi	r31, 0x00	; 0
 86e:	80 81       	ld	r24, Z
 870:	88 23       	and	r24, r24
 872:	dc f7       	brge	.-10     	; 0x86a <UART_recieveByte+0x8>
	/* Read the received data from the Rx buffer (UDR) and the RXC flag 
	   will be cleared after read this data */	 
    return UDR;		
 874:	ec e2       	ldi	r30, 0x2C	; 44
 876:	f0 e0       	ldi	r31, 0x00	; 0
 878:	80 81       	ld	r24, Z
}
 87a:	cf 91       	pop	r28
 87c:	df 91       	pop	r29
 87e:	08 95       	ret

00000880 <UART_sendString>:

void UART_sendString(const uint8 *Str)
{
 880:	df 93       	push	r29
 882:	cf 93       	push	r28
 884:	00 d0       	rcall	.+0      	; 0x886 <UART_sendString+0x6>
 886:	0f 92       	push	r0
 888:	cd b7       	in	r28, 0x3d	; 61
 88a:	de b7       	in	r29, 0x3e	; 62
 88c:	9b 83       	std	Y+3, r25	; 0x03
 88e:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
 890:	19 82       	std	Y+1, r1	; 0x01
 892:	0e c0       	rjmp	.+28     	; 0x8b0 <UART_sendString+0x30>
	while(Str[i] != '\0')
	{
		UART_sendByte(Str[i]);
 894:	89 81       	ldd	r24, Y+1	; 0x01
 896:	28 2f       	mov	r18, r24
 898:	30 e0       	ldi	r19, 0x00	; 0
 89a:	8a 81       	ldd	r24, Y+2	; 0x02
 89c:	9b 81       	ldd	r25, Y+3	; 0x03
 89e:	fc 01       	movw	r30, r24
 8a0:	e2 0f       	add	r30, r18
 8a2:	f3 1f       	adc	r31, r19
 8a4:	80 81       	ld	r24, Z
 8a6:	0e 94 1a 04 	call	0x834	; 0x834 <UART_sendByte>
		i++;
 8aa:	89 81       	ldd	r24, Y+1	; 0x01
 8ac:	8f 5f       	subi	r24, 0xFF	; 255
 8ae:	89 83       	std	Y+1, r24	; 0x01
}

void UART_sendString(const uint8 *Str)
{
	uint8 i = 0;
	while(Str[i] != '\0')
 8b0:	89 81       	ldd	r24, Y+1	; 0x01
 8b2:	28 2f       	mov	r18, r24
 8b4:	30 e0       	ldi	r19, 0x00	; 0
 8b6:	8a 81       	ldd	r24, Y+2	; 0x02
 8b8:	9b 81       	ldd	r25, Y+3	; 0x03
 8ba:	fc 01       	movw	r30, r24
 8bc:	e2 0f       	add	r30, r18
 8be:	f3 1f       	adc	r31, r19
 8c0:	80 81       	ld	r24, Z
 8c2:	88 23       	and	r24, r24
 8c4:	39 f7       	brne	.-50     	; 0x894 <UART_sendString+0x14>
	{
		UART_sendByte(*Str);
		Str++;
	}		
	*******************************************************************/
}
 8c6:	0f 90       	pop	r0
 8c8:	0f 90       	pop	r0
 8ca:	0f 90       	pop	r0
 8cc:	cf 91       	pop	r28
 8ce:	df 91       	pop	r29
 8d0:	08 95       	ret

000008d2 <UART_receiveString>:

void UART_receiveString(uint8 *Str)
{
 8d2:	0f 93       	push	r16
 8d4:	1f 93       	push	r17
 8d6:	df 93       	push	r29
 8d8:	cf 93       	push	r28
 8da:	00 d0       	rcall	.+0      	; 0x8dc <UART_receiveString+0xa>
 8dc:	0f 92       	push	r0
 8de:	cd b7       	in	r28, 0x3d	; 61
 8e0:	de b7       	in	r29, 0x3e	; 62
 8e2:	9b 83       	std	Y+3, r25	; 0x03
 8e4:	8a 83       	std	Y+2, r24	; 0x02
	uint8 i = 0;
 8e6:	19 82       	std	Y+1, r1	; 0x01
	Str[i] = UART_recieveByte();
 8e8:	89 81       	ldd	r24, Y+1	; 0x01
 8ea:	28 2f       	mov	r18, r24
 8ec:	30 e0       	ldi	r19, 0x00	; 0
 8ee:	8a 81       	ldd	r24, Y+2	; 0x02
 8f0:	9b 81       	ldd	r25, Y+3	; 0x03
 8f2:	8c 01       	movw	r16, r24
 8f4:	02 0f       	add	r16, r18
 8f6:	13 1f       	adc	r17, r19
 8f8:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 8fc:	f8 01       	movw	r30, r16
 8fe:	80 83       	st	Z, r24
 900:	0f c0       	rjmp	.+30     	; 0x920 <UART_receiveString+0x4e>
	while(Str[i] != '#')
	{
		i++;
 902:	89 81       	ldd	r24, Y+1	; 0x01
 904:	8f 5f       	subi	r24, 0xFF	; 255
 906:	89 83       	std	Y+1, r24	; 0x01
		Str[i] = UART_recieveByte();
 908:	89 81       	ldd	r24, Y+1	; 0x01
 90a:	28 2f       	mov	r18, r24
 90c:	30 e0       	ldi	r19, 0x00	; 0
 90e:	8a 81       	ldd	r24, Y+2	; 0x02
 910:	9b 81       	ldd	r25, Y+3	; 0x03
 912:	8c 01       	movw	r16, r24
 914:	02 0f       	add	r16, r18
 916:	13 1f       	adc	r17, r19
 918:	0e 94 31 04 	call	0x862	; 0x862 <UART_recieveByte>
 91c:	f8 01       	movw	r30, r16
 91e:	80 83       	st	Z, r24

void UART_receiveString(uint8 *Str)
{
	uint8 i = 0;
	Str[i] = UART_recieveByte();
	while(Str[i] != '#')
 920:	89 81       	ldd	r24, Y+1	; 0x01
 922:	28 2f       	mov	r18, r24
 924:	30 e0       	ldi	r19, 0x00	; 0
 926:	8a 81       	ldd	r24, Y+2	; 0x02
 928:	9b 81       	ldd	r25, Y+3	; 0x03
 92a:	fc 01       	movw	r30, r24
 92c:	e2 0f       	add	r30, r18
 92e:	f3 1f       	adc	r31, r19
 930:	80 81       	ld	r24, Z
 932:	83 32       	cpi	r24, 0x23	; 35
 934:	31 f7       	brne	.-52     	; 0x902 <UART_receiveString+0x30>
	{
		i++;
		Str[i] = UART_recieveByte();
	}
	Str[i] = '\0';
 936:	89 81       	ldd	r24, Y+1	; 0x01
 938:	28 2f       	mov	r18, r24
 93a:	30 e0       	ldi	r19, 0x00	; 0
 93c:	8a 81       	ldd	r24, Y+2	; 0x02
 93e:	9b 81       	ldd	r25, Y+3	; 0x03
 940:	fc 01       	movw	r30, r24
 942:	e2 0f       	add	r30, r18
 944:	f3 1f       	adc	r31, r19
 946:	10 82       	st	Z, r1
}
 948:	0f 90       	pop	r0
 94a:	0f 90       	pop	r0
 94c:	0f 90       	pop	r0
 94e:	cf 91       	pop	r28
 950:	df 91       	pop	r29
 952:	1f 91       	pop	r17
 954:	0f 91       	pop	r16
 956:	08 95       	ret

00000958 <__udivmodsi4>:
 958:	a1 e2       	ldi	r26, 0x21	; 33
 95a:	1a 2e       	mov	r1, r26
 95c:	aa 1b       	sub	r26, r26
 95e:	bb 1b       	sub	r27, r27
 960:	fd 01       	movw	r30, r26
 962:	0d c0       	rjmp	.+26     	; 0x97e <__udivmodsi4_ep>

00000964 <__udivmodsi4_loop>:
 964:	aa 1f       	adc	r26, r26
 966:	bb 1f       	adc	r27, r27
 968:	ee 1f       	adc	r30, r30
 96a:	ff 1f       	adc	r31, r31
 96c:	a2 17       	cp	r26, r18
 96e:	b3 07       	cpc	r27, r19
 970:	e4 07       	cpc	r30, r20
 972:	f5 07       	cpc	r31, r21
 974:	20 f0       	brcs	.+8      	; 0x97e <__udivmodsi4_ep>
 976:	a2 1b       	sub	r26, r18
 978:	b3 0b       	sbc	r27, r19
 97a:	e4 0b       	sbc	r30, r20
 97c:	f5 0b       	sbc	r31, r21

0000097e <__udivmodsi4_ep>:
 97e:	66 1f       	adc	r22, r22
 980:	77 1f       	adc	r23, r23
 982:	88 1f       	adc	r24, r24
 984:	99 1f       	adc	r25, r25
 986:	1a 94       	dec	r1
 988:	69 f7       	brne	.-38     	; 0x964 <__udivmodsi4_loop>
 98a:	60 95       	com	r22
 98c:	70 95       	com	r23
 98e:	80 95       	com	r24
 990:	90 95       	com	r25
 992:	9b 01       	movw	r18, r22
 994:	ac 01       	movw	r20, r24
 996:	bd 01       	movw	r22, r26
 998:	cf 01       	movw	r24, r30
 99a:	08 95       	ret

0000099c <_exit>:
 99c:	f8 94       	cli

0000099e <__stop_program>:
 99e:	ff cf       	rjmp	.-2      	; 0x99e <__stop_program>
